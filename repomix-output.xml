This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Assets/Scripts/**/*.cs
- Files matching these patterns are excluded: Library/, Temp/, Obj/, Build/, Builds/, Logs/, *.log, *.tmp, *.bak, *.cache, *.csproj, *.sln, *.user, *.unityproj, *.pidb, *.booproj, *.svd, *.pdb, *.mdb, *.opendb, *.VC.db, *.pidb.meta, *.pdb.meta, *.mdb.meta, *.opendb.meta, *.VC.db.meta, Assets/Scripts/Player/PlayerControls.cs
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Assets/
  Scripts/
    AudioManager.cs
    Bonfire.cs
    DashGost.cs
    DifficultyManager.cs
    Enemy.cs
    EnemyCommon.cs
    EnemyFast.cs
    EnemySpawner.cs
    EnemyTank.cs
    GameEvents.cs
    GameManager.cs
    JiggleEffect.cs
    LightFlicker.cs
    PlayerController.cs
    Rarity.cs
    RarityManager.cs
    SwordSlashEffect.cs
    ThrownWood.cs
    UIWobbleEffect.cs
    UpgradeData.cs
    UpgradeEffect.cs
    UpgradeUIManager.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Assets/Scripts/GameEvents.cs">
// Assets/Scripts/GameEvents.cs
using System;
using UnityEngine;

/// <summary>
/// Classe estática central para todos os eventos do jogo, usando C# Actions.
/// Isso ajuda a desacoplar os sistemas, permitindo que eles reajam a eventos
/// sem precisarem de referências diretas uns aos outros.
/// </summary>
public static class GameEvents
{
    // Disparado quando um inimigo é morto. Passa o componente do Inimigo para contexto.
    public static event Action<Enemy> OnEnemyKilled;
    public static void RaiseEnemyKilled(Enemy enemy) => OnEnemyKilled?.Invoke(enemy);

    // Disparado quando a fogueira coleta lenha. Passa o valor de XP daquela lenha.
    public static event Action<float> OnWoodCollected;
    public static void RaiseWoodCollected(float xpValue) => OnWoodCollected?.Invoke(xpValue);

    // Disparado quando o jogador sobe de nível. Passa o novo nível.
    public static event Action<int> OnPlayerLevelUp;
    public static void RaisePlayerLevelUp(int newLevel) => OnPlayerLevelUp?.Invoke(newLevel);

    // Disparado quando o jogo começa oficialmente (após o painel inicial).
    public static event Action OnGameStart;
    public static void RaiseGameStart() => OnGameStart?.Invoke();

    // Disparado quando o jogo é perdido (fogueira apaga).
    public static event Action OnGameOver;
    public static void RaiseGameOver() => OnGameOver?.Invoke();

    // Disparado quando o jogo é vencido (tempo esgota).
    public static event Action OnGameWin;
    public static void RaiseGameWin() => OnGameWin?.Invoke();
    
    // Disparado quando a primeira parte do jogo é vencida.
    public static event Action OnFirstPartWin;
    public static void RaiseFirstPartWin() => OnFirstPartWin?.Invoke();
}
</file>

<file path="Assets/Scripts/DashGost.cs">
using UnityEngine;

public class DashGhost : MonoBehaviour
{
    public float duration = 0.3f;
    private SpriteRenderer sr;

    void Start()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr == null)
        {
            Debug.LogWarning("DashGhost: SpriteRenderer não encontrado!");
            Destroy(gameObject); // Se não tem sprite, destrói
            return;
        }

        sr.sortingOrder -= 1;
        Color color = sr.color;
        color.a = 0.8f; // começa com transparência visível
        sr.color = color;

        Destroy(gameObject, duration);
    }

    void Update()
    {
        if (sr == null) return;

        Color color = sr.color;
        color.a -= Time.deltaTime / duration;
        sr.color = color;
    }
}
</file>

<file path="Assets/Scripts/JiggleEffect.cs">
using UnityEngine;
using DG.Tweening;

public class JiggleEffect : MonoBehaviour
{
    [Header("Configuração do Jiggle")]
    public float scaleAmount = 0.05f;       // Quanto a escala oscila
    public float positionAmount = 0.05f;    // Quanto a posição oscila
    public float duration = 0.3f;           // Duração de cada fase

    private Vector3 originalScale;
    private Vector3 originalPos;

    void Start()
    {
        originalScale = transform.localScale;
        originalPos = transform.localPosition;

        StartJiggle();
    }

    void StartJiggle()
    {
        Sequence seq = DOTween.Sequence().SetLoops(-1, LoopType.Yoyo);

        seq.Append(transform.DOScale(originalScale + new Vector3(scaleAmount, -scaleAmount, 0), duration).SetEase(Ease.InOutSine));
        seq.Join(transform.DOLocalMove(originalPos + new Vector3(positionAmount, positionAmount, 0), duration).SetEase(Ease.InOutSine));

        seq.Append(transform.DOScale(originalScale + new Vector3(-scaleAmount, scaleAmount, 0), duration).SetEase(Ease.InOutSine));
        seq.Join(transform.DOLocalMove(originalPos + new Vector3(-positionAmount, -positionAmount, 0), duration).SetEase(Ease.InOutSine));
    }
}
</file>

<file path="Assets/Scripts/Rarity.cs">
// Assets/Scripts/Rarity.cs

// Este enum define os diferentes níveis de raridade para os upgrades.
public enum Rarity
{
    Common,
    Rare,
    Legendary,
    Cursed
}
</file>

<file path="Assets/Scripts/RarityManager.cs">
// Assets/Scripts/RarityManager.cs
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class RarityManager : MonoBehaviour
{
    public static RarityManager Instance { get; private set; }

    // Classe interna para configurar cada raridade no Inspector
    [System.Serializable]
    public class RarityInfo
    {
        public Rarity rarity;
        public Color displayColor;
        [Range(0f, 100f)]
        public float baseDropChance; // Chance em porcentagem (ex: 60 para 60%)
    }

    [Header("Configuração de Raridades")]
    [Tooltip("Defina a cor e a chance de drop para cada raridade.")]
    public List<RarityInfo> raritySettings;
    
    [Header("Modificadores Globais")]
    [Tooltip("Multiplicador para a chance de raridades altas (Épico, Lendário). Alterado por upgrades como 'Coroa de Midas'.")]
    public float highTierChanceMultiplier = 1.0f;

    private Dictionary<Rarity, RarityInfo> rarityMap;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            InitializeManager();
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void InitializeManager()
    {
        // Converte a lista em um dicionário para acesso rápido e fácil
        rarityMap = new Dictionary<Rarity, RarityInfo>();
        foreach (var setting in raritySettings)
        {
            if (!rarityMap.ContainsKey(setting.rarity))
            {
                rarityMap.Add(setting.rarity, setting);
            }
        }
    }

    /// <summary>
    /// Retorna a cor associada a uma raridade específica.
    /// </summary>
    public Color GetRarityColor(Rarity rarity)
    {
        if (rarityMap.TryGetValue(rarity, out RarityInfo info))
        {
            return info.displayColor;
        }
        return Color.white; // Cor padrão caso não encontre
    }

    /// <summary>
    /// Seleciona uma raridade aleatória com base nas chances configuradas.
    /// </summary>
    public Rarity SelectRandomRarity()
    {
        // Cria uma lista de chances ponderadas
        Dictionary<Rarity, float> weightedChances = new Dictionary<Rarity, float>();
        foreach (var info in raritySettings)
        {
            float currentChance = info.baseDropChance;
            // Aplica o bônus da "Coroa de Midas" para raridades altas
            if (info.rarity == Rarity.Cursed || info.rarity == Rarity.Legendary)
            {
                currentChance *= highTierChanceMultiplier;
            }
            weightedChances.Add(info.rarity, currentChance);
        }

        float totalChanceWeight = weightedChances.Values.Sum();
        float randomRoll = Random.Range(0f, totalChanceWeight);

        // Percorre as raridades e subtrai suas chances do valor aleatório.
        // A primeira raridade que fizer o valor ficar abaixo de zero é a escolhida.
        foreach (var weightedChance in weightedChances)
        {
            randomRoll -= weightedChance.Value;
            if (randomRoll <= 0f)
            {
                return weightedChance.Key;
            }
        }

        // Como fallback, caso algo dê errado, retorna a raridade Comum.
        return Rarity.Common;
    }
}
</file>

<file path="Assets/Scripts/SwordSlashEffect.cs">
using UnityEngine;
using DG.Tweening;

[RequireComponent(typeof(SpriteRenderer))]
public class SwordSlashEffect : MonoBehaviour
{
    [Header("Configurações da Animação")]
    [Tooltip("Duração total da animação do corte, em segundos.")]
    public float animationDuration = 0.3f;

    [Tooltip("Escala final que o sprite irá atingir.")]
    public float targetScale = 1.5f;

    [Tooltip("Rotação final do sprite em graus. Use valores como 90, -90, etc., para mudar a direção do corte.")]
    public float targetRotation = 45f;

    private SpriteRenderer spriteRenderer;

    void Awake()
    {
        // Garante que temos a referência do SpriteRenderer
        spriteRenderer = GetComponent<SpriteRenderer>();
        if (spriteRenderer == null)
        {
            Debug.LogError("SwordSlashEffect precisa de um componente SpriteRenderer neste GameObject!");
            Destroy(gameObject); // Destrói se não houver sprite para animar
        }
    }

    void Start()
    {
        // Garante que o alfa inicial do sprite seja 1 (totalmente visível)
        Color startColor = spriteRenderer.color;
        startColor.a = 1f;
        spriteRenderer.color = startColor;

        // Inicia o sprite com escala zero para que ele "apareça" do nada
        transform.localScale = Vector3.zero;

        // Cria e executa a sequência de animação com DOTween
        AnimateSlash();
    }

    private void AnimateSlash()
    {
        // Cria uma sequência para rodar várias animações ao mesmo tempo
        Sequence slashSequence = DOTween.Sequence();

        // 1. Animação de Escala: cresce do zero até a escala alvo.
        slashSequence.Join(transform.DOScale(targetScale, animationDuration)
            .SetEase(Ease.OutQuad)); // Ease.OutQuad dá uma sensação de "explosão" inicial

        // 2. Animação de Fade: desaparece ao longo da duração.
        slashSequence.Join(spriteRenderer.DOFade(0f, animationDuration)
            .SetEase(Ease.InQuad)); // Ease.InQuad faz o fade acelerar no final

        // // 3. Animação de Rotação: gira para dar um efeito de arco.
        // slashSequence.Join(transform.DORotate(new Vector3(0, 0, targetRotation), animationDuration, RotateMode.FastBeyond360)
        //     .SetEase(Ease.OutSine));

        // Define uma ação para ser executada QUANDO a sequência terminar
        slashSequence.OnComplete(() =>
        {
            // Destrói o GameObject ao final de toda a animação
            Destroy(gameObject);
        });
    }
}
</file>

<file path="Assets/Scripts/ThrownWood.cs">
// ThrownWood.cs
using UnityEngine;
using DG.Tweening;

[RequireComponent(typeof(Rigidbody2D))]
public class ThrownWood : MonoBehaviour
{
    [Header("Configuração da Animação")]
    public float arcHeight = 2f;
    public float spinSpeed = 720f;

    [Header("Gameplay")]
    [Tooltip("Quantidade de XP que esta lenha concede ao ser coletada pela fogueira.")]
    public float xpValue = 1f; // O valor de XP agora é um float.

    // Flag para controlar se a lenha pode ser coletada
    public bool isCollectible = false;

    private void Start()
    {
        Rigidbody2D rb = GetComponent<Rigidbody2D>();
        rb.isKinematic = true;
        
        Collider2D col = GetComponent<Collider2D>();
        if (col != null) col.isTrigger = true;

        // Torna a lenha coletável após um curto período para evitar
        // que o jogador a pegue de volta instantaneamente.
        // DOVirtual.DelayedCall é uma forma limpa do DOTween de fazer um timer.
        DOVirtual.DelayedCall(0.2f, () => {
            isCollectible = true;
        });
    }

    public void Launch(Vector3 targetPosition, float duration)
    {
        Sequence launchSequence = DOTween.Sequence();
        Vector3 startPoint = transform.position;
        Vector3 midPoint = UnityEngine.Vector3.Lerp(startPoint, targetPosition, 0.5f) + (UnityEngine.Vector3.up * arcHeight);
        Vector3[] path = { midPoint, targetPosition };
        launchSequence.Append(transform.DOPath(path, duration, PathType.CatmullRom).SetEase(Ease.OutQuad));
        launchSequence.Join(transform.DORotate(new Vector3(0, 0, spinSpeed * duration), duration, RotateMode.FastBeyond360).SetEase(Ease.Linear));
    }
}
</file>

<file path="Assets/Scripts/UpgradeEffect.cs">
// Assets/Scripts/UpgradeEffect.cs
using System;

// Marcamos como [Serializable] para que possa ser editado no Inspector da Unity
// dentro da lista de efeitos do UpgradeData.
[Serializable]
public class UpgradeEffect
{
    public UpgradeType type; // O tipo de efeito (ex: aumentar velocidade de ataque)
    public float value;      // O valor do efeito (ex: 1.25 para +25%)
}
</file>

<file path="Assets/Scripts/DifficultyManager.cs">
// Assets/Scripts/DifficultyManager.cs
using UnityEngine;

public class DifficultyManager : MonoBehaviour
{
    public static DifficultyManager Instance { get; private set; }

    [Header("Controle de Tempo")]
    [Tooltip("Duração total da partida em segundos (ex: 120 para 2 minutos).")]
    public float totalMatchTime = 300f;
    private float elapsedTime = 0f;
    private bool isGameActive = true;

    [Header("Curvas de Dificuldade (0 a 1)")]
    [Tooltip("Controla a taxa de spawn. X=0 (início), X=1 (fim). Y é o multiplicador.")]
    public AnimationCurve spawnRateCurve;

    [Tooltip("Controla a velocidade dos inimigos.")]
    public AnimationCurve enemySpeedCurve;

    [Tooltip("Controla a vida dos inimigos.")]

    public AnimationCurve enemyHealthCurve;

    // --- Propriedades Públicas para outros scripts consultarem ---
    public float SpawnRateMultiplier;
    public float EnemySpeedMultiplier;
    public float EnemyHealthMultiplier;
    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        // Garante que o jogo comece na dificuldade inicial
        UpdateDifficulty(0);
    }

    private void Update()
    {
        if (!isGameActive) return;

        elapsedTime += Time.deltaTime;

        // Calcula o progresso do tempo como uma porcentagem de 0 a 1
        float timeProgress = Mathf.Clamp01(elapsedTime / totalMatchTime);

        UpdateDifficulty(timeProgress);

        // Se o tempo acabar, você pode adicionar uma condição de vitória aqui
        if (elapsedTime >= totalMatchTime)
        {
            isGameActive = false;
            Debug.Log("SOBREVIVEU! VITÓRIA!");
            // GameManager.Instance.WinGame();
        }
    }

    private void UpdateDifficulty(float progress)
    {
        // Avalia cada curva para obter os multiplicadores atuais
        SpawnRateMultiplier = spawnRateCurve.Evaluate(progress);
        EnemySpeedMultiplier = enemySpeedCurve.Evaluate(progress);
        EnemyHealthMultiplier = enemyHealthCurve.Evaluate(progress);
    }

    public void StopTimer()
    {
        isGameActive = false;
    }
    public void ResetTimer()
    {
        isGameActive = true;
    }
}
</file>

<file path="Assets/Scripts/EnemyCommon.cs">
// Assets/Scripts/EnemyCommon.cs
using UnityEngine;

public class EnemyCommon : Enemy
{
    [Header("Movimento Comum")]
    public float swaySpeed = 2f;
    public float swayAmount = 1.5f;
    private float randomOffset;

    protected override void Start()
    {
        base.Start(); // Executa o Start() da classe mãe
        randomOffset = Random.Range(0f, 100f); // Garante que cada inimigo se mova diferente
    }

    protected override void Move()
    {
        // Direção principal para a fogueira
        Vector2 directionToTarget = (target.position - transform.position).normalized;
        
        // Direção perpendicular para o balanço
        Vector2 perpendicular = new Vector2(-directionToTarget.y, directionToTarget.x);
        
        // Usa Perlin Noise para um movimento de balanço suave e orgânico
        float sway = (Mathf.PerlinNoise(Time.time * swaySpeed, randomOffset) - 0.5f) * 2f; // Valor entre -1 e 1
        
        // Combina a direção principal com o balanço
        Vector2 finalDirection = (directionToTarget + perpendicular * sway * swayAmount).normalized;
        
        transform.Translate(finalDirection * finalSpeed * Time.deltaTime, Space.World);    }
}
</file>

<file path="Assets/Scripts/LightFlicker.cs">
using UnityEngine;
using UnityEngine.Rendering.Universal;

[RequireComponent(typeof(Light2D))]
public class LightFlicker : MonoBehaviour
{
    [Header("Configuração do Efeito")]
    [Tooltip("Quão forte a luz pisca, como uma porcentagem da intensidade atual. (ex: 0.1 para 10%)")]
    [Range(0f, 1f)]
    public float intensityVariation = 0.1f;

    [Tooltip("Quão forte o raio pisca, como uma porcentagem do raio atual. (ex: 0.1 para 10%)")]
    [Range(0f, 1f)]
    public float radiusVariation = 0.1f;

    [Tooltip("A velocidade com que o efeito de piscar ocorre.")]
    public float flickerSpeed = 0.08f;

    [Header("Limites Mínimos")]
    [Tooltip("A intensidade mínima que a luz terá quando a fogueira estiver com 0 de vida.")]
    public float minIntensity = 0.2f;

    [Tooltip("O raio mínimo que a luz terá quando a fogueira estiver com 0 de vida.")]
    public float minOuterRadius = 1.5f;

    // --- Variáveis Privadas ---
    private Light2D light2D;
    private float flickerTimer;

    // Guardam os valores máximos possíveis, capturados no início ou aumentados por upgrades
    private float maxPossibleIntensity;
    private float maxPossibleOuterRadius;

    // Guardam o valor base ATUAL, que é definido pela fogueira a cada frame
    private float currentBaseIntensity;
    private float currentBaseOuterRadius;
    internal float baseIntensity;

    void Awake()
    {
        // É uma boa prática pegar componentes no Awake
        light2D = GetComponent<Light2D>();
    }

    void Start()
    {
        // REQUISITO 1: Captura os valores do Inspector no momento do Play como os MÁXIMOS iniciais.
        maxPossibleIntensity = light2D.intensity;
        maxPossibleOuterRadius = light2D.pointLightOuterRadius;
    }

    void Update()
    {
        flickerTimer += Time.deltaTime;
        if (flickerTimer >= flickerSpeed)
        {
            flickerTimer = 0f;

            // REQUISITO 3: O flicker (a variação) é calculado com base na FORÇA ATUAL da luz.
            float intensityFlickerRange = currentBaseIntensity * intensityVariation;
            float newIntensity = currentBaseIntensity + Random.Range(-intensityFlickerRange, intensityFlickerRange);

            float radiusFlickerRange = currentBaseOuterRadius * radiusVariation;
            float newOuterRadius = currentBaseOuterRadius + Random.Range(-radiusFlickerRange, radiusFlickerRange);
            
            // Aplica os valores finais à luz, garantindo que não passem do máximo possível
            light2D.intensity = Mathf.Clamp(newIntensity, minIntensity, maxPossibleIntensity);
            light2D.pointLightOuterRadius = Mathf.Clamp(newOuterRadius, minOuterRadius, maxPossibleOuterRadius);
        }
    }

    /// <summary>
    /// Este é o método principal que a Fogueira chamará para definir a força da luz.
    /// </summary>
    /// <param name="strengthPercent">A força da luz, de 0.0 (apagada) a 1.0 (força máxima).</param>
    public void UpdateLightStrength(float strengthPercent)
    {
        // REQUISITO 4: A força atual é baseada na vida da fogueira.
        // Usamos Lerp para encontrar o valor base entre o mínimo e o máximo possível.
        currentBaseIntensity = Mathf.Lerp(minIntensity, maxPossibleIntensity, strengthPercent);
        currentBaseOuterRadius = Mathf.Lerp(minOuterRadius, maxPossibleOuterRadius, strengthPercent);
    }
    
    /// <summary>
    /// Este método será chamado pelo upgrade para aumentar os limites máximos da luz.
    /// </summary>
    public void UpgradeLightMaximums(float multiplier)
    {
        // REQUISITO 2: O máximo só aumenta com upgrades.
        maxPossibleIntensity *= multiplier;
        maxPossibleOuterRadius *= multiplier;
    }
}
</file>

<file path="Assets/Scripts/UIWobbleEffect.cs">
// Assets/Scripts/UI/UIWobbleEffect.cs
using UnityEngine;
using DG.Tweening; // Não se esqueça de importar o DOTween

public class UIWobbleEffect : MonoBehaviour
{
    [Header("Configuração do Movimento")]
    [Tooltip("Distância máxima que o elemento se moverá no eixo X (esquerda/direita).")]
    public float moveDistanceX = 10f;

    [Tooltip("Distância máxima que o elemento se moverá no eixo Y (cima/baixo).")]
    public float moveDistanceY = 15f;

    [Header("Configuração de Tempo e Aleatoriedade")]
    [Tooltip("A duração base para cada movimento de 'onda'.")]
    public float baseDuration = 1.5f;

    [Tooltip("Controla o quão aleatório será o movimento. 0 = sem aleatoriedade (onda perfeita), 1 = muito aleatório.")]
    [Range(0f, 1f)]
    public float randomness = 0.5f;

    [Header("Controle")]
    [Tooltip("Se marcado, o efeito começa a tocar assim que o objeto for ativado.")]
    public bool playOnAwake = true;

    // --- Variáveis Privadas ---
    private Vector3 originalPosition;
    private Sequence mainSequence;

    private void Awake()
    {
        // Guarda a posição inicial para que o efeito seja sempre relativo a ela
        originalPosition = transform.localPosition;
    }

    private void OnEnable()
    {
        // Reinicia o efeito se o objeto for reativado
        if (playOnAwake)
        {
            Play();
        }
    }

    private void OnDisable()
    {
        // Para a animação quando o objeto é desativado para evitar erros
        Stop();
    }

    /// <summary>
    /// Inicia o efeito de ondulação.
    /// </summary>
    public void Play()
    {
        // Garante que não haja sequências antigas rodando
        if (mainSequence != null && mainSequence.IsActive())
        {
            mainSequence.Kill();
        }

        // Inicia o primeiro movimento
        StartWobble();
    }

    /// <summary>
    /// Para o efeito e retorna o elemento à sua posição original.
    /// </summary>
    public void Stop()
    {
        mainSequence?.Kill();
        // Opcional: Anima suavemente de volta à posição original
        transform.DOLocalMove(originalPosition, 0.2f).SetEase(Ease.OutCubic);
    }
    
    /// <summary>
    /// O coração do efeito. Esta função se chama recursivamente
    /// ao final de cada movimento para criar um loop infinito e aleatório.
    /// </summary>
    private void StartWobble()
    {
        // Calcula parâmetros aleatórios para ESTE movimento específico
        float randomDurationFactor = Random.Range(1f - randomness, 1f + randomness);
        float currentDuration = baseDuration * randomDurationFactor;

        // Calcula um ponto alvo aleatório dentro dos limites definidos
        float targetX = originalPosition.x + Random.Range(-moveDistanceX, moveDistanceX);
        float targetY = originalPosition.y + Random.Range(-moveDistanceY, moveDistanceY);

        // Cria a sequência de animação
        mainSequence = DOTween.Sequence(true).SetUpdate(UpdateType.Normal, true);
        mainSequence.Append(transform.DOLocalMove(new Vector3(targetX, targetY, originalPosition.z), currentDuration)
                .SetEase(Ease.InOutSine)) // Ease.InOutSine cria a sensação suave de "onda"
            .OnComplete(StartWobble); // Magia! Ao completar, chama a si mesma para o próximo movimento.
    }
}
</file>

<file path="Assets/Scripts/AudioManager.cs">
using UnityEngine;
using System.Collections.Generic;

public class AudioManager : MonoBehaviour
{
    public static AudioManager Instance { get; private set; }

    [Header("Músicas")]
    [Tooltip("Lista de músicas de fundo disponíveis.")]
    public List<AudioClip> backgroundMusicClips = new List<AudioClip>(); // Lista de músicas
    public AudioSource bgmAudioSource;

    [Header("Efeitos Sonoros")]
    public AudioSource sfxAudioSource;
    [Tooltip("Lista dos clipes de áudio dos efeitos sonoros.")]
    public List<AudioClip> soundEffectClips;

    private const float PITCH_VARIATION_PERCENTAGE = 0.10f; // 10%

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        // Exemplo: Inicia a música do menu ao carregar a cena inicial
        PlayBackgroundMusic(0); // Assume que a música do menu é o primeiro clipe na lista
    }

    /// <summary>
    /// Toca uma música de fundo específica da lista.
    /// </summary>
    /// <param name="musicIndex">O índice da música na lista 'backgroundMusicClips'.</param>
    public void PlayBackgroundMusic(int musicIndex)
    {
        Debug.Log($"Tocando música de fundo: {musicIndex}");
        if (bgmAudioSource == null || backgroundMusicClips.Count == 0)
        {
            Debug.LogWarning("AudioManager: bgmAudioSource não atribuído ou lista de músicas vazia.");
            return;
        }

        if (musicIndex < 0 || musicIndex >= backgroundMusicClips.Count || backgroundMusicClips[musicIndex] == null)
        {
            Debug.LogWarning($"AudioManager: Índice de música inválido ({musicIndex}).");
            return;
        }

        bgmAudioSource.clip = backgroundMusicClips[musicIndex];
        bgmAudioSource.loop = true;
        ApplyRandomPitch(bgmAudioSource);
        bgmAudioSource.Play();
    }



    /// <summary>
    /// Para a música de fundo.
    /// </summary>
    public void StopBackgroundMusic()
    {
        if (bgmAudioSource != null)
        {
            bgmAudioSource.Stop();
        }
    }

    /// <summary>
    /// Toca um efeito sonoro específico da lista.
    /// </summary>
    /// <param name="sfxIndex">O índice do efeito sonoro na lista 'soundEffectClips'.</param>
    /// <param name="volumeScale">Escala de volume opcional para este efeito sonoro (padrão é 1.0f).</param>
    public void PlaySoundEffect(int sfxIndex, float volumeScale = 1.0f)
    {
        if (sfxAudioSource == null)
        {
            Debug.LogWarning("AudioManager: sfxAudioSource não foi atribuído. Efeito sonoro não pode ser tocado.");
            return;
        }

        if (sfxIndex < 0 || sfxIndex >= soundEffectClips.Count || soundEffectClips[sfxIndex] == null)
        {
            Debug.LogWarning($"AudioManager: Índice de efeito sonoro inválido ({sfxIndex}) ou clipe de áudio não atribuído.");
            return;
        }

        ApplyRandomPitch(sfxAudioSource);
        sfxAudioSource.PlayOneShot(soundEffectClips[sfxIndex], volumeScale);
    }

    public void PlayConfettiSound()
    {
        if (sfxAudioSource == null)
        {
            Debug.LogWarning("AudioManager: sfxAudioSource não foi atribuído. Efeito sonoro de confete não pode ser tocado.");
            return;
        }

        AudioClip confettiClip = soundEffectClips.Find(clip => clip.name.Contains("Confetti"));
        if (confettiClip != null)
        {
            ApplyRandomPitch(sfxAudioSource);
            sfxAudioSource.PlayOneShot(confettiClip);
        }
        else
        {
            Debug.LogWarning("AudioManager: Clip de confete não encontrado na lista de efeitos sonoros.");
        }
    }

    public void PlaySoundEffectClip(AudioClip clip, float volumeScale = 1.0f)
  {
    if (sfxAudioSource == null)
    {
      Debug.LogWarning("AudioManager: sfxAudioSource não foi atribuído. Efeito sonoro não pode ser tocado.");
      return;
    }

    if (clip == null)
    {
      Debug.LogWarning("AudioManager: Clip de áudio é nulo. Efeito sonoro não pode ser tocado.");
      return;
    }

    ApplyRandomPitch(sfxAudioSource);
    sfxAudioSource.PlayOneShot(clip, volumeScale);
  }

    private void ApplyRandomPitch(AudioSource audioSource)
  {
    float randomPitch = Random.Range(1f - PITCH_VARIATION_PERCENTAGE, 1f + PITCH_VARIATION_PERCENTAGE);
    audioSource.pitch = randomPitch;
  }
}
</file>

<file path="Assets/Scripts/EnemyFast.cs">
// Assets/Scripts/EnemyFast.cs
using UnityEngine;

public class EnemyFast : Enemy
{
    [Header("Movimento Rápido")]
    public float spiralFrequency = 3f; // Quão rápido ele oscila
    public float spiralMagnitude = 0.8f; // Quão largo é o círculo da espiral

    protected override void Start()
    {
        // Stats: Rápido e com menos vida (AGORA APLICA ANTES do modificador de dificuldade)

        // Chama o Start da classe base, que vai aplicar os modificadores de dificuldade em cima desses novos valores
        base.Start();
    }
    protected override void Move()
    {
        Vector2 directionToTarget = (target.position - transform.position).normalized;
        Vector2 perpendicular = new Vector2(-directionToTarget.y, directionToTarget.x);
        
        // Usa Seno para criar um movimento circular perfeito
        float spiralOffset = Mathf.Sin(Time.time * spiralFrequency) * spiralMagnitude;
        
        Vector2 finalDirection = (directionToTarget + perpendicular * spiralOffset).normalized;
        
        transform.Translate(finalDirection * finalSpeed * Time.deltaTime, Space.World);    }
}
</file>

<file path="Assets/Scripts/EnemySpawner.cs">
// Assets/Scripts/EnemySpawner.cs
using System.Collections;
using UnityEngine;

public class EnemySpawner : MonoBehaviour
{
    [Header("Prefabs dos Inimigos")]
    public GameObject commonEnemyPrefab;
    public GameObject fastEnemyPrefab;
    public GameObject tankEnemyPrefab;

    [Header("Configuração do Spawn")]
    [Tooltip("A taxa de spawn base (inimigos por segundo) no início do jogo.")]
    public float baseSpawnRate = 1f;
    public float spawnRadius = 15f;

    [Header("Chances de Spawn (0.0 a 1.0)")]
    [Range(0f, 1f)]
    public float fastEnemyChance = 0.1f;
    [Range(0f, 1f)]
    public float tankEnemyChance = 0.1f;

    private Transform bonfire;
    private bool isSpawning = false; // Flag para garantir que a rotina não inicie duas vezes

    void Start()
    {
        // Apenas pega a referência, não inicia o spawn
        bonfire = GameObject.FindGameObjectWithTag("Bonfire").transform;
    }

    // Este método é o único ponto de entrada para começar a spawnar
    public void StartSpawning()
    {
        if (isSpawning) return; // Se já estiver spawnando, não faz nada
        isSpawning = true;
        
        Debug.Log("Iniciando a rotina de spawn de inimigos...");
        StartCoroutine(SpawnRoutine());
    }

    private IEnumerator SpawnRoutine()
    {
        while (isSpawning)
        {
            // Calcula a taxa de spawn atual usando o DifficultyManager
            float currentSpawnRate = baseSpawnRate * DifficultyManager.Instance.SpawnRateMultiplier;
            float waitTime = 1f / currentSpawnRate;
            
            yield return new WaitForSeconds(waitTime);

            SpawnEnemy();
        }
    }

    void SpawnEnemy()
    {
        GameObject prefabToSpawn;
        float randomValue = Random.value;

        if (randomValue < fastEnemyChance) prefabToSpawn = fastEnemyPrefab;
        else if (randomValue < fastEnemyChance + tankEnemyChance) prefabToSpawn = tankEnemyPrefab;
        else prefabToSpawn = commonEnemyPrefab;
        
        if (prefabToSpawn == null) return;

        Vector2 spawnPos = (Vector2)bonfire.position + Random.insideUnitCircle.normalized * spawnRadius;
        Instantiate(prefabToSpawn, spawnPos, Quaternion.identity);
    }
}
</file>

<file path="Assets/Scripts/EnemyTank.cs">
// Assets/Scripts/EnemyTank.cs
using UnityEngine;

public class EnemyTank : Enemy
{
    protected override void Start()
    {
        // Stats: Lento e com mais vida.
        // Define a quantidade base de lenha que o Tank dropa. Este valor será
        // afetado por multiplicadores de upgrades.
        baseWoodToDrop = 2f; // Ex: Dropa 2 lenhas garantidas.

        // Chama o Start da classe base, que vai aplicar os modificadores de dificuldade.
        base.Start();
    }

    // Movimento simples e direto.
    protected override void Move()
    {
        transform.position = Vector2.MoveTowards(transform.position, target.position, finalSpeed * Time.deltaTime);
    }

    // O método Die() foi REMOVIDO. Agora ele usa a lógica unificada da classe base 'Enemy',
    // tornando o código mais limpo e evitando duplicação. A lógica de drop especial
    // é controlada pela variável 'baseWoodToDrop'.
}
</file>

<file path="Assets/Scripts/UpgradeData.cs">
// Assets/Scripts/UpgradeData.cs
using UnityEngine;
using System.Collections.Generic; // Necessário para usar List

// Enum para identificar facilmente o tipo de upgrade
public enum UpgradeType
{
    // Player Stats
    PlayerMoveSpeed,
    PlayerAttackSpeed,
    PlayerAttackRange,
    PlayerAttackDamage,
    PlayerDashCooldown,

    // Bonfire Stats
    BonfireMaxHealth,
    BonfireBurnRate,
    WoodHealingAmount,
    HealBonfire,

    // Global Modifiers
    WoodDropChance,
    IncreaseHighRarityChance, // Efeito da "Coroa de Midas"

    // Complex/Cursed Effects
    DashCooldownOnKill, // Matar inimigos reduz o cooldown do dash
    CritChance,             // Aumenta a chance de acerto crítico
    CritDamage,             // Aumenta o dano do acerto crítico
    LifeSteal,              // Rouba vida ao causar dano
    ExplosionOnKill,        // Causa uma explosão ao matar um inimigo
    DashDealsDamage,        // O dash causa dano e atravessa inimigos
    SlowOnHit,              // Ataques aplicam lentidão
    BurnOnHit,              // Ataques aplicam dano de queimadura ao longo do tempo
    BonfirePulseDamage,     // Fogueira pulsa dano em área
    GoldPlatedEnemies,      // Inimigos têm mais chance de dropar Cerne-Chama, mas são mais fortes
    // ProjectilePierce,       // O Cerne-Chama arremessado atravessa inimigos
    PlayerHealthRegen,      // Regeneração passiva de vida do jogador
    DamageAuraPlayer,       // Dano em área constante ao redor do jogador
    EnemySpawnDelay,        // Aumenta o tempo entre spawns de inimigos
    HealthForSpeed,         // Troca vida máxima por velocidade de movimento
    AttackDamagePerMissingHealth, // Aumenta dano com base na vida perdida do jogador
    BonfireShield,          // Fogueira recebe escudo temporário
    ExplosionChanceOnHit,   // Chance de explosão no impacto do ataque
    DamageOnDashEnd,        // Causa dano em área ao final do dash
    BonfireHealOnPlayerKill,
}

[CreateAssetMenu(fileName = "New Upgrade", menuName = "Game/Upgrade Data")]
public class UpgradeData : ScriptableObject
{
    [Header("Info")]
    public string upgradeName;
    [TextArea(3, 5)]
    public string description;
    public Sprite icon;

    [Header("Configuração")]
    public Rarity rarity; // A raridade deste upgrade
    
    // Um upgrade agora pode ter múltiplos efeitos
    public List<UpgradeEffect> effects = new List<UpgradeEffect>();
}
</file>

<file path="Assets/Scripts/UpgradeUIManager.cs">
// Assets/Scripts/UpgradeUIManager.cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using TMPro;

public class UpgradeUIManager : MonoBehaviour
{
    public GameObject upgradePanel;
    public List<Button> upgradeButtons;
    public List<Image> upgradeRarityBorders; // << NOVO: Referência para a borda/fundo do card
    public List<TextMeshProUGUI> upgradeNameTexts;
    public List<TextMeshProUGUI> upgradeDescriptionTexts;
    public List<Image> upgradeIcons;

    public void ShowUpgradeOptions(List<UpgradeData> upgrades)
    {
        upgradePanel.SetActive(true);
        DisableButtons();
        // Assumindo que você tem um script de animação, como UIJuice. Se não, remova esta linha.
        // GetComponent<UIJuice>().PlayAnimation();

        for (int i = 0; i < upgradeButtons.Count; i++)
        {
            if (i < upgrades.Count && upgrades[i] != null)
            {
                upgradeButtons[i].gameObject.SetActive(true);
                upgradeNameTexts[i].text = upgrades[i].upgradeName;
                upgradeDescriptionTexts[i].text = upgrades[i].description;
                upgradeIcons[i].sprite = upgrades[i].icon;

                // Define a cor da borda com base na raridade
                if (RarityManager.Instance != null && i < upgradeRarityBorders.Count)
                {
                    upgradeRarityBorders[i].color = RarityManager.Instance.GetRarityColor(upgrades[i].rarity);
                }

                upgradeButtons[i].onClick.RemoveAllListeners();
                var selectedUpgrade = upgrades[i];
                upgradeButtons[i].onClick.AddListener(() => GameManager.Instance.ApplyUpgrade(selectedUpgrade));
                // O painel agora é escondido pelo próprio GameManager após aplicar o upgrade
            }
            else
            {
                upgradeButtons[i].gameObject.SetActive(false);
            }
        }
    }

    public void HidePanel()
    {
        // Assumindo que você tem um script de animação. Se não, apenas desative o painel.
        // GetComponent<UIJuice>().PlayReverseAnimation();
        upgradePanel.SetActive(false); // Alternativa simples

        foreach (var button in upgradeButtons)
        {
            button.interactable = false;
            button.onClick.RemoveAllListeners();
        }
    }
    
    public void EnableButtons()
    {
        foreach (var button in upgradeButtons)
        {
            button.interactable = true;
        }
    }
    
    public void DisableButtons()
    {
        foreach (var button in upgradeButtons)
        {
            button.interactable = false;
        }
    }
}
</file>

<file path="Assets/Scripts/Bonfire.cs">
// Assets/Scripts/Bonfire.cs
using UnityEngine;
using UnityEngine.UI; // Necessário para controlar o Slider

public class Bonfire : MonoBehaviour
{
    [Header("Health & Burning")]
    [Tooltip("Vida máxima atual da fogueira.")]
    public float maxHealth = 100f;
    [Tooltip("Vida atual da fogueira.")]
    public float currentHealth;

    [Tooltip("A taxa de queima base quando a fogueira está com vida baixa.")]
    public float baseBurnRate = 0.5f; // Perda de energia por segundo
    [Tooltip("Multiplicador da taxa de queima quando a fogueira está com vida máxima.")]
    public float maxHealthBurnMultiplier = 2.5f; // A 100% de vida, queima 2.5x mais rápido

    public float logHealingAmount = 10f; // Quanto de vida a fogueira ganha ao coletar lenha
    [Tooltip("Controla como a taxa de queima aumenta com a vida. X=0 (0% vida), Y=1 (taxa base). X=1 (100% vida), Y=2.5 (taxa máxima).")]
    public AnimationCurve burnRateCurve = AnimationCurve.EaseInOut(0, 1, 1, 15f);

    [Header("Referências de UI e VFX")]
    [Tooltip("O Slider da UI que representa a vida da fogueira.")]
    public Slider healthSlider;
    [Tooltip("O sistema de partículas principal da fogueira.")]
    public ParticleSystem fireParticleSystem;
    [Tooltip("O componente de luz da fogueira.")]
    public LightFlicker bonfireLight;

    private float initialParticleGravity;
    private float initialParticleStartSize;
    private float initialParticleStartSpeed;
    private float initialParticleEmissionRate;

    public bool isInvincible = false;

    void Start()
    {
        currentHealth = maxHealth;

        if (bonfireLight == null) Debug.LogError("Referência para LightFlicker não definida no Bonfire!");
        if (fireParticleSystem == null) Debug.LogError("Referência para ParticleSystem não definida no Bonfire!");
        else
        {
            var mainModule = fireParticleSystem.main;
            initialParticleGravity = mainModule.gravityModifier.constant;
            initialParticleStartSize = mainModule.startSize.constant;
            initialParticleStartSpeed = mainModule.startSpeed.constant;
            initialParticleEmissionRate = fireParticleSystem.emission.rateOverTime.constant;
        }

        if (healthSlider == null) Debug.LogError("Referência para o Health Slider não definida no Bonfire!");

        UpdateHealthSlider();
    }

    void Update()
    {
        TakeBurnDamage();
        UpdateHealthSlider();
    }

    void OnTriggerEnter2D(Collider2D other)
    {
        if (other.CompareTag("Lenha"))
        {
            ThrownWood woodScript = other.GetComponent<ThrownWood>();
            if (woodScript != null)
            {
                AudioManager.Instance.PlaySoundEffect(6);

                // Dispara o evento global de coleta de lenha, passando o valor de XP.
                GameEvents.RaiseWoodCollected(woodScript.xpValue);

                Destroy(other.gameObject); // Remove a lenha do jogo

                // Cura a fogueira (lógica de cura permanece a mesma).
                currentHealth += logHealingAmount;
                currentHealth = Mathf.Min(currentHealth, maxHealth);
                GameManager.Instance.SpawnOrangeExplosion(transform.position); // Efeito visual.
            }
        }
    }

    private void TakeBurnDamage()
    {
        if (isInvincible) return;
        float healthPercent = currentHealth / maxHealth;
        float currentBurnMultiplier = burnRateCurve.Evaluate(healthPercent);
        float currentBurnRate = baseBurnRate * currentBurnMultiplier;
        currentHealth -= currentBurnRate * Time.deltaTime;
        currentHealth = Mathf.Max(currentHealth, 0);

        UpdateFireVisuals(healthPercent);

        if (currentHealth <= 0)
        {
            currentHealth = 0;
            // O GameManager agora ouve o evento OnGameOver, então a chamada direta pode ser removida se preferir.
            // Por enquanto, manter a chamada direta garante que a lógica funcione.
            GameManager.Instance.LoseGame();
            Debug.Log("A FOGUEIRA APAGOU! GAME OVER.");
        }
    }

    private void UpdateHealthSlider()
    {
        if (healthSlider == null) return;
        healthSlider.maxValue = maxHealth;
        healthSlider.value = currentHealth;
    }

    private void UpdateFireVisuals(float healthPercent)
    {
        if (fireParticleSystem != null)
        {
            var main = fireParticleSystem.main;
            main.gravityModifier = Mathf.Lerp(initialParticleGravity * 0.5f, initialParticleGravity * 3, healthPercent);
            main.startSize = Mathf.Lerp(initialParticleStartSize * 0.5f, initialParticleStartSize * 2f, healthPercent);
            main.startSpeed = Mathf.Lerp(initialParticleStartSpeed * 0.75f, initialParticleStartSpeed * 5f, healthPercent);
            var emission = fireParticleSystem.emission;
            emission.rateOverTime = Mathf.Lerp(initialParticleEmissionRate * 0.5f, initialParticleEmissionRate * 3f, healthPercent);
        }

        if (bonfireLight != null)
        {
            bonfireLight.UpdateLightStrength(healthPercent);
        }
    }

    public void AddHealth(float amount)
    {
        currentHealth += amount;
        currentHealth = Mathf.Min(currentHealth, maxHealth);
        GameManager.Instance.SpawnOrangeExplosionOnBonfire();
    }

    public void ReceberDano(float dano)
    {
        if (isInvincible) return;
        currentHealth -= dano;
    }

    public void IncreaseMaxHealth(float multiplier)
    {
        float oldMaxHealth = maxHealth;
        maxHealth *= multiplier;
        float healthGained = maxHealth - oldMaxHealth;
        currentHealth += healthGained;
        currentHealth = Mathf.Clamp(currentHealth, 0, maxHealth);
        UpdateHealthSlider();

        if (bonfireLight != null)
        {
            bonfireLight.UpgradeLightMaximums(multiplier);
        }
    }

    public void HealToFull()
    {
        currentHealth = maxHealth;
    }
}
</file>

<file path="Assets/Scripts/PlayerController.cs">
// Assets/Scripts/PlayerController.cs
using System.Linq;
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class PlayerController : MonoBehaviour
{
    [Header("Movimentação")]
    public float moveSpeed = 8f;
    public float acceleration = 10f;

    [Header("Dash")]
    public float dashForce = 12f;
    public float dashDuration = 0.2f;
    public float dashCooldown = 2f;
    public KeyCode dashKey = KeyCode.Space;

    [Header("Inventário")]
    public int lenhaNoInventario = 0;

    private Rigidbody2D rb;
    private Vector2 input;
    private bool isDashing = false;
    private float lastDashTime = -Mathf.Infinity;

    [Header("Ataque Melee Automático")]
    public float attackRadius = 2.5f;
    public float attackCooldown = 1f;
    public float attackDamage = 1;
    public LayerMask enemyLayer;
    public GameObject slashEffectPrefab;
    private float lastAttackTime = -Mathf.Infinity;

    [Header("Lançar Lenha")]
    public GameObject woodPrefab;
    public float throwDuration = 0.7f;
    private Transform bonfireTransform;
    
    private void Awake()
    {
        // Se inscreve no evento global de morte de inimigos.
        GameEvents.OnEnemyKilled += HandleEnemyKilled;
    }
    
    private void OnDestroy()
    {
        // Cancela a inscrição para evitar erros e memory leaks quando o objeto for destruído.
        GameEvents.OnEnemyKilled -= HandleEnemyKilled;
    }

    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        GameObject bonfireObj = GameObject.FindGameObjectWithTag("Bonfire");
        if (bonfireObj != null)
        {
            bonfireTransform = bonfireObj.transform;
        }
    }

    void Update()
    {
        HandleInput();
        HandleDashInput();
        HandleMeleeAttack();
    }

    void FixedUpdate()
    {
        if (!isDashing)
        {
            Vector2 targetVelocity = input * moveSpeed;
            rb.velocity = Vector2.Lerp(rb.velocity, targetVelocity, acceleration * Time.fixedDeltaTime);
        }
    }
    
    /// <summary>
    /// Handler que é chamado quando o evento GameEvents.OnEnemyKilled é disparado.
    /// </summary>
    private void HandleEnemyKilled(Enemy killedEnemy)
    {
        // A lógica é simplesmente resetar o cooldown do dash.
        // O parâmetro 'killedEnemy' não é usado aqui, mas é exigido pela assinatura do evento.
        ResetDashCooldown();
    }

    void HandleMeleeAttack()
    {
        if (Time.time >= lastAttackTime + attackCooldown)
        {
            Collider2D[] enemiesInRange = Physics2D.OverlapCircleAll(transform.position, attackRadius, enemyLayer);

            if (enemiesInRange.Length > 0)
            {
                Transform closestEnemy = enemiesInRange
                    .OrderBy(enemy => Vector2.Distance(transform.position, enemy.transform.position))
                    .FirstOrDefault()?.transform;

                if (closestEnemy != null)
                {
                    lastAttackTime = Time.time;
                    Enemy enemyScript = closestEnemy.GetComponent<Enemy>();

                    if (enemyScript != null)
                    {
                        enemyScript.TakeDamage(attackDamage);

                        if (slashEffectPrefab != null)
                        {
                            Vector2 directionToEnemy = (closestEnemy.position - transform.position).normalized;
                            float angle = Mathf.Atan2(directionToEnemy.y, directionToEnemy.x) * Mathf.Rad2Deg;
                            Quaternion targetRotation = Quaternion.Euler(0f, 0f, angle);
                            Instantiate(slashEffectPrefab, closestEnemy.position, targetRotation);
                        }
                    }
                }
            }
        }
    }

    void HandleInput()
    {
        input = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical")).normalized;
    }

    System.Collections.IEnumerator Dash()
    {
        isDashing = true;
        lastDashTime = Time.time;
        Vector2 dashDir = input != Vector2.zero ? input : (transform.up);
        rb.velocity = dashDir.normalized * dashForce;
        yield return new WaitForSeconds(dashDuration);
        isDashing = false;
    }

    void HandleDashInput()
    {
        if (Input.GetKeyDown(dashKey) && Time.time >= lastDashTime + dashCooldown && !isDashing)
        {
            AudioManager.Instance.PlaySoundEffect(2);
            StartCoroutine(Dash());
        }
    }

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Lenha"))
        {
            ThrownWood woodScript = collision.GetComponent<ThrownWood>();
            if (woodScript != null && !woodScript.isCollectible) return;

            lenhaNoInventario++;
            Destroy(collision.gameObject);
            ThrowWood();
        }
        if (collision.CompareTag("Bonfire"))
        {
            ResetDashCooldown();
        }
    }

    private void OnTriggerStay2D(Collider2D collision)
    {
        if (collision.CompareTag("Lenha"))
        {
            ThrownWood woodScript = collision.GetComponent<ThrownWood>();
            if (woodScript != null && !woodScript.isCollectible) return;

            lenhaNoInventario++;
            Destroy(collision.gameObject);
            ThrowWood();
        }
    }

    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRadius);
    }

    public void ThrowWood()
    {
        lenhaNoInventario--;
        GameObject wood = Instantiate(woodPrefab, transform.position, Quaternion.identity);
        ThrownWood thrownWoodScript = wood.GetComponent<ThrownWood>();

        if (thrownWoodScript != null && bonfireTransform != null)
        {
            thrownWoodScript.Launch(bonfireTransform.position, throwDuration);
        }
    }

    public void ResetDashCooldown()
    {
        lastDashTime = -Mathf.Infinity;
    }

    public void ReduceDashCooldown(float amount)
    {
        if (!isDashing)
        {
            lastDashTime -= amount;
        }
    }
}
</file>

<file path="Assets/Scripts/Enemy.cs">
// Assets/Scripts/Enemy.cs
using UnityEngine;
using DG.Tweening;
using Random = UnityEngine.Random;

public abstract class Enemy : MonoBehaviour
{
    [Header("Atributos Base (antes da dificuldade)")]
    public float baseSpeed = 3f;
    public float baseMaxHealth = 2;
    public float dano = 4;
    protected float currentHealth;

    [Header("Drops")]
    public GameObject woodDropPrefab;
    [Tooltip("Define a quantidade base de lenha que este inimigo dropa. Pode ser um valor fracionado (ex: 0.5 para 50% de chance de dropar 1).")]
    public float baseWoodToDrop = 0.5f;

    // Variáveis internas
    protected float finalSpeed;
    protected Transform target;
    protected SpriteRenderer sr;
    protected bool fireDeath = false;

    protected virtual void Start()
    {
        ApplyDifficultyModifiers();
        currentHealth = baseMaxHealth;
        sr = GetComponentInChildren<SpriteRenderer>();

        GameObject bonfireObject = GameObject.FindGameObjectWithTag("Bonfire");
        if (bonfireObject != null)
        {
            target = bonfireObject.transform;
        }
    }

    protected virtual void ApplyDifficultyModifiers()
    {
        finalSpeed = baseSpeed * DifficultyManager.Instance.EnemySpeedMultiplier;
        baseMaxHealth = Mathf.RoundToInt(baseMaxHealth * DifficultyManager.Instance.EnemyHealthMultiplier);
    }

    private void Update()
    {
        if (target != null)
        {
            Move();
        }
    }

    protected abstract void Move();

    public void TakeDamage(float damage)
    {
        AudioManager.Instance.PlaySoundEffect(2);
        currentHealth -= damage;
        sr.DOColor(Color.white, 0.1f).SetLoops(2, LoopType.Yoyo);

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    protected virtual void Die()
    {
        // Dispara o evento global, passando este componente do inimigo para qualquer script que esteja ouvindo.
        GameEvents.RaiseEnemyKilled(this);

        GameManager.Instance.SpawnBlueExplosion(transform.position);

        if (fireDeath)
        {
            AudioManager.Instance.PlaySoundEffect(6);
            GameManager.Instance.SpawnOrangeExplosion(transform.position);
        }
        else
        {
            // A lógica de drop só acontece se o inimigo não morreu na fogueira.
            HandleDrops();
        }

        Destroy(gameObject);
    }

    /// <summary>
    /// Calcula e instancia os drops de lenha com base na quantidade esperada.
    /// </summary>
    protected virtual void HandleDrops()
    {
        if (woodDropPrefab == null) return;

        // Calcula a quantidade de drops com base no valor do inimigo e no multiplicador global.
        float expectedDrops = baseWoodToDrop * GameManager.Instance.woodDropMultiplier;
        int wholeDrops = Mathf.FloorToInt(expectedDrops);
        float fractionalChance = expectedDrops - wholeDrops;

        // Dropa a quantidade garantida.
        for (int i = 0; i < wholeDrops; i++)
        {
            SpawnWood();
        }

        // Verifica a chance fracionária de dropar um extra.
        if (Random.value < fractionalChance)
        {
            SpawnWood();
        }
    }

    /// <summary>
    /// Instancia uma única peça de lenha na posição do inimigo.
    /// </summary>
    private void SpawnWood()
    {
        AudioManager.Instance.PlaySoundEffect(0);
        // Adiciona um pequeno offset aleatório para que as lenhas não fiquem empilhadas.
        Vector2 spawnPos = (Vector2)transform.position + Random.insideUnitCircle * 0.5f;
        Instantiate(woodDropPrefab, spawnPos, Quaternion.identity);
    }


    protected virtual void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Bonfire"))
        {
            collision.GetComponent<Bonfire>().ReceberDano(dano);
            fireDeath = true;
            Die();
        }
    }
}
</file>

<file path="Assets/Scripts/GameManager.cs">
// Assets/Scripts/GameManager.cs
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class GameManager : MonoBehaviour
{
    private bool isGameRunning = false;
    public float timeToWin = 300, timeToWinFirst = 120;
    public static GameManager Instance { get; private set; }

    [Header("Referências")]
    public PlayerController player;
    public Bonfire bonfire;
    public UpgradeUIManager upgradeUI;
    public EnemySpawner enemySpawner;
    public RarityManager rarityManager;

    [Header("UI")]
    public GameObject losePanel;
    public GameObject firstWinPanel, winPanel;
    public GameObject startPanel;
    public TextMeshProUGUI levelText;
    public Slider xpSlider;

    [Header("Controle de Nível")]
    public int playerLevel = 1;
    private float currentXp = 0f; // XP agora é um float para mais precisão.
    public int[] xpPerLevel = { 1, 2, 3, 4, 5, 7, 9, 30, 38, 47 };

    [Header("Upgrades")]
    [Tooltip("Lista com todos os upgrades possíveis no jogo.")]
    public List<UpgradeData> allUpgrades;
    private List<UpgradeData> offeredUpgradesPool;

    public ParticleSystem confettiEffect, orangeExplosionEffect, blueExplosionEffect;

    [Header("Stats Globais Modificáveis por Upgrades")]
    [Tooltip("Multiplicador para a QUANTIDADE de lenha dropada pelos inimigos. 1 = 100% do base, 1.5 = 150% do base.")]
    public float woodDropMultiplier = 1f; // Nome alterado para clareza.
    public float dashCooldownReductionOnKill = 0f;
    private bool godMode = false;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
        
        // Se inscreve nos eventos globais para reagir a eles.
        GameEvents.OnWoodCollected += AddXp;
        GameEvents.OnEnemyKilled += HandleEnemyKill;
        GameEvents.OnGameOver += HandleGameOver;
    }

    private void OnDestroy()
    {
        // Sempre cancele a inscrição ao destruir o objeto para evitar memory leaks.
        GameEvents.OnWoodCollected -= AddXp;
        GameEvents.OnEnemyKilled -= HandleEnemyKill;
        GameEvents.OnGameOver -= HandleGameOver;
    }

    private void Start()
    {
        losePanel.SetActive(false);
        if (winPanel != null) winPanel.SetActive(false);
        Time.timeScale = 0f;
    }

    public void StartGame()
    {
        if (isGameRunning) return;
        isGameRunning = true;
        Time.timeScale = 1f;
        AudioManager.Instance.PlayBackgroundMusic(1);
        offeredUpgradesPool = new List<UpgradeData>();

        if (enemySpawner == null) Debug.LogError("Referência ao EnemySpawner não foi definida no GameManager!");
        if (rarityManager == null) Debug.LogError("Referência ao RarityManager não foi definida no GameManager!");
        
        enemySpawner.StartSpawning();
        StartCoroutine(VictoryTimer());
        StartCoroutine(SecondPartTimer());
        GameEvents.RaiseGameStart(); // Dispara evento de início de jogo.
    }

    private IEnumerator VictoryTimer()
    {
        yield return new WaitForSeconds(timeToWin);
        WinGame();
    }

    private IEnumerator SecondPartTimer()
    {
        yield return new WaitForSeconds(timeToWinFirst);
        FirstPartWin();
    }

    // Handler para o evento de morte de inimigo (usado para upgrades específicos).
    private void HandleEnemyKill(Enemy killedEnemy)
    {
        if (dashCooldownReductionOnKill > 0)
        {
            player.ReduceDashCooldown(dashCooldownReductionOnKill);
        }
    }

    // Método que ouve o evento OnWoodCollected. Aceita float.
    public void AddXp(float amount)
    {
        if (playerLevel > xpPerLevel.Length) return;
        currentXp += amount;
        xpSlider.value = currentXp / xpPerLevel[playerLevel - 1];
        Debug.Log($"Ganhou {amount:F2} XP. Total: {currentXp:F2}/{xpPerLevel[playerLevel - 1]}");

        if (currentXp >= xpPerLevel[playerLevel - 1])
        {
            LevelUp();
        }
    }

    public void LevelUp()
    {
        currentXp -= xpPerLevel[playerLevel - 1];
        playerLevel++;
        levelText.text = $"Lv.: {playerLevel}";
        ShowConfetti();
        Debug.Log($"LEVEL UP! Novo nível: {playerLevel}");
        AudioManager.Instance.PlaySoundEffect(5);
        GameEvents.RaisePlayerLevelUp(playerLevel); // Dispara evento de level up.

        Time.timeScale = 0f;

        List<UpgradeData> selectedUpgrades = GetUpgradeChoices();
        upgradeUI.ShowUpgradeOptions(selectedUpgrades);
    }

    private List<UpgradeData> GetUpgradeChoices()
    {
        List<UpgradeData> choices = new List<UpgradeData>();
        offeredUpgradesPool.Clear();

        for (int i = 0; i < 3; i++)
        {
            Rarity targetRarity = rarityManager.SelectRandomRarity();
            Debug.Log($"Escolhendo upgrade de raridade: {targetRarity}");

            List<UpgradeData> availableByRarity = allUpgrades
                .Where(u => u.rarity == targetRarity && !offeredUpgradesPool.Contains(u))
                .ToList();

            if (availableByRarity.Count == 0)
            {
                availableByRarity = allUpgrades
                    .Where(u => u.rarity <= targetRarity && !offeredUpgradesPool.Contains(u))
                    .ToList();
            }

            if (availableByRarity.Count == 0)
            {
                offeredUpgradesPool.Clear();
                availableByRarity = allUpgrades.Where(u => u.rarity <= targetRarity).ToList();
            }

            if (availableByRarity.Count > 0)
            {
                UpgradeData chosenUpgrade = availableByRarity[Random.Range(0, availableByRarity.Count)];
                choices.Add(chosenUpgrade);
                offeredUpgradesPool.Add(chosenUpgrade);
            }
        }
        return choices;
    }

    public void ApplyUpgrade(UpgradeData upgrade)
    {
        Debug.Log($"Upgrade '{upgrade.upgradeName}' (Raridade: {upgrade.rarity}) selecionado. Aplicando {upgrade.effects.Count} efeito(s).");

        foreach (var effect in upgrade.effects)
        {
            switch (effect.type)
            {
                case UpgradeType.PlayerAttackSpeed:
                    player.attackCooldown /= effect.value;
                    break;
                case UpgradeType.PlayerMoveSpeed:
                    player.moveSpeed *= effect.value;
                    break;
                case UpgradeType.PlayerAttackRange:
                    player.attackRadius *= effect.value;
                    break;
                case UpgradeType.PlayerDashCooldown:
                    player.dashCooldown /= effect.value;
                    break;
                case UpgradeType.PlayerAttackDamage:
                    player.attackDamage *= effect.value;
                    break;
                case UpgradeType.BonfireBurnRate:
                    bonfire.baseBurnRate *= effect.value;
                    break;
                case UpgradeType.BonfireMaxHealth:
                    bonfire.IncreaseMaxHealth(effect.value);
                    break;
                case UpgradeType.HealBonfire:
                    bonfire.HealToFull();
                    break;
                case UpgradeType.WoodHealingAmount:
                    bonfire.logHealingAmount += effect.value;
                    break;
                case UpgradeType.WoodDropChance: // O enum continua com este nome
                    woodDropMultiplier *= effect.value; // mas a lógica usa a variável correta.
                    break;
                case UpgradeType.DashCooldownOnKill:
                    dashCooldownReductionOnKill += effect.value;
                    break;
                case UpgradeType.IncreaseHighRarityChance:
                    rarityManager.highTierChanceMultiplier *= effect.value;
                    break;
            }
        }

        Time.timeScale = 1f;
        upgradeUI.HidePanel();
    }

    #region Game Control & VFX
    public void ShowConfetti()
    {
        if (confettiEffect != null) confettiEffect.Play();
    }

    public void SpawnOrangeExplosion(Vector3 position)
    {
        if (orangeExplosionEffect != null)
        {
            var effect = Instantiate(orangeExplosionEffect, position, Quaternion.identity);
            effect.transform.position += new Vector3(0, 0, -1f);
        }
    }

    public void SpawnOrangeExplosionOnBonfire()
    {
        if (bonfire != null) SpawnOrangeExplosion(bonfire.transform.position);
    }

    public void SpawnBlueExplosion(Vector3 position)
    {
        if (blueExplosionEffect != null)
        {
            var effect = Instantiate(blueExplosionEffect, position, Quaternion.identity);
            effect.transform.position += new Vector3(0, 0, -1f);
        }
    }

    public void WinGame()
    {
        Debug.Log("Você sobreviveu! Vitória!");
        if (winPanel != null) winPanel.SetActive(true);
        Time.timeScale = 0f;
        DifficultyManager.Instance.StopTimer();
        GameEvents.RaiseGameWin(); // Dispara evento de vitória.
    }

    public void FirstPartWin()
    {
        Debug.Log("Você sobreviveu à primeira parte! Vitória Parcial!");
        if (firstWinPanel != null) firstWinPanel.SetActive(true);
        confettiEffect.Play();
        Time.timeScale = 0f;
        DifficultyManager.Instance.StopTimer();
        GameEvents.RaiseFirstPartWin(); // Dispara evento de vitória parcial.
    }

    public void StartSecondPart()
    {
        Debug.Log("Iniciando a segunda parte do jogo...");
        Time.timeScale = 1f;
        isGameRunning = true;
        DifficultyManager.Instance.ResetTimer();
    }

    public void LoseGame()
    {
        if (godMode) return;
        // Apenas dispara o evento. A lógica de UI e pause está no handler.
        GameEvents.RaiseGameOver();
    }

    private void HandleGameOver()
    {
        Debug.Log("Você perdeu! Exibindo painel de derrota.");
        losePanel.SetActive(true);
        Time.timeScale = 0f;
        DifficultyManager.Instance.StopTimer();
    }

    public void RestartGame()
    {
        Time.timeScale = 1f;
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }

    public void QuitGame()
    {
        Application.Quit();
    }

    public void SwitchGodMode()
    {
        godMode = !godMode;
        if (godMode)
        {
            bonfire.HealToFull();
            bonfire.isInvincible = true;
        }
        else
        {
            bonfire.isInvincible = false;
        }
    }
    #endregion
}
</file>

</files>
