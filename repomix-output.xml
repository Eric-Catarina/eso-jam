This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Assets/Scripts/**/*.cs
- Files matching these patterns are excluded: Library/, Temp/, Obj/, Build/, Builds/, Logs/, *.log, *.tmp, *.bak, *.cache, *.csproj, *.sln, *.user, *.unityproj, *.pidb, *.booproj, *.svd, *.pdb, *.mdb, *.opendb, *.VC.db, *.pidb.meta, *.pdb.meta, *.mdb.meta, *.opendb.meta, *.VC.db.meta, Assets/Scripts/Player/PlayerControls.cs
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Assets/
  Scripts/
    AudioManager.cs
    Bonfire.cs
    DashGost.cs
    Enemy.cs
    EnemySpawner.cs
    GameManager.cs
    JiggleEffect.cs
    LightFlicker.cs
    PlayerController.cs
    SwordSlashEffect.cs
    ThrownWood.cs
    UpgradeData.cs
    UpgradeUIManager.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Assets/Scripts/AudioManager.cs">
using UnityEngine;
using System.Collections.Generic;

public class AudioManager : MonoBehaviour
{
    public static AudioManager Instance { get; private set; }

    [Header("Músicas")]
    [Tooltip("Lista de músicas de fundo disponíveis.")]
    public List<AudioClip> backgroundMusicClips = new List<AudioClip>(); // Lista de músicas
    public AudioSource bgmAudioSource;

    [Header("Efeitos Sonoros")]
    public AudioSource sfxAudioSource;
    [Tooltip("Lista dos clipes de áudio dos efeitos sonoros.")]
    public List<AudioClip> soundEffectClips;

    private const float PITCH_VARIATION_PERCENTAGE = 0.10f; // 10%

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        // Exemplo: Inicia a música do menu ao carregar a cena inicial
        PlayBackgroundMusic(0); // Assume que a música do menu é o primeiro clipe na lista
    }

    /// <summary>
    /// Toca uma música de fundo específica da lista.
    /// </summary>
    /// <param name="musicIndex">O índice da música na lista 'backgroundMusicClips'.</param>
    public void PlayBackgroundMusic(int musicIndex)
    {
        if (bgmAudioSource == null || backgroundMusicClips.Count == 0)
        {
            Debug.LogWarning("AudioManager: bgmAudioSource não atribuído ou lista de músicas vazia.");
            return;
        }

        if (musicIndex < 0 || musicIndex >= backgroundMusicClips.Count || backgroundMusicClips[musicIndex] == null)
        {
            Debug.LogWarning($"AudioManager: Índice de música inválido ({musicIndex}).");
            return;
        }

        bgmAudioSource.clip = backgroundMusicClips[musicIndex];
        bgmAudioSource.loop = true;
        ApplyRandomPitch(bgmAudioSource);
        bgmAudioSource.Play();
    }

    /// <summary>
    /// Para a música de fundo.
    /// </summary>
    public void StopBackgroundMusic()
    {
        if (bgmAudioSource != null)
        {
            bgmAudioSource.Stop();
        }
    }

    /// <summary>
    /// Toca um efeito sonoro específico da lista.
    /// </summary>
    /// <param name="sfxIndex">O índice do efeito sonoro na lista 'soundEffectClips'.</param>
    /// <param name="volumeScale">Escala de volume opcional para este efeito sonoro (padrão é 1.0f).</param>
    public void PlaySoundEffect(int sfxIndex, float volumeScale = 1.0f)
    {
        if (sfxAudioSource == null)
        {
            Debug.LogWarning("AudioManager: sfxAudioSource não foi atribuído. Efeito sonoro não pode ser tocado.");
            return;
        }

        if (sfxIndex < 0 || sfxIndex >= soundEffectClips.Count || soundEffectClips[sfxIndex] == null)
        {
            Debug.LogWarning($"AudioManager: Índice de efeito sonoro inválido ({sfxIndex}) ou clipe de áudio não atribuído.");
            return;
        }

        ApplyRandomPitch(sfxAudioSource);
        sfxAudioSource.PlayOneShot(soundEffectClips[sfxIndex], volumeScale);
    }

    public void PlayConfettiSound()
    {
        if (sfxAudioSource == null)
        {
            Debug.LogWarning("AudioManager: sfxAudioSource não foi atribuído. Efeito sonoro de confete não pode ser tocado.");
            return;
        }

        AudioClip confettiClip = soundEffectClips.Find(clip => clip.name.Contains("Confetti"));
        if (confettiClip != null)
        {
            ApplyRandomPitch(sfxAudioSource);
            sfxAudioSource.PlayOneShot(confettiClip);
        }
        else
        {
            Debug.LogWarning("AudioManager: Clip de confete não encontrado na lista de efeitos sonoros.");
        }
    }

    public void PlaySoundEffectClip(AudioClip clip, float volumeScale = 1.0f)
  {
    if (sfxAudioSource == null)
    {
      Debug.LogWarning("AudioManager: sfxAudioSource não foi atribuído. Efeito sonoro não pode ser tocado.");
      return;
    }

    if (clip == null)
    {
      Debug.LogWarning("AudioManager: Clip de áudio é nulo. Efeito sonoro não pode ser tocado.");
      return;
    }

    ApplyRandomPitch(sfxAudioSource);
    sfxAudioSource.PlayOneShot(clip, volumeScale);
  }

    private void ApplyRandomPitch(AudioSource audioSource)
  {
    float randomPitch = Random.Range(1f - PITCH_VARIATION_PERCENTAGE, 1f + PITCH_VARIATION_PERCENTAGE);
    audioSource.pitch = randomPitch;
  }
}
</file>

<file path="Assets/Scripts/DashGost.cs">
using UnityEngine;

public class DashGhost : MonoBehaviour
{
    public float duration = 0.3f;
    private SpriteRenderer sr;

    void Start()
    {
        sr = GetComponent<SpriteRenderer>();
        if (sr == null)
        {
            Debug.LogWarning("DashGhost: SpriteRenderer não encontrado!");
            Destroy(gameObject); // Se não tem sprite, destrói
            return;
        }

        sr.sortingOrder -= 1;
        Color color = sr.color;
        color.a = 0.8f; // começa com transparência visível
        sr.color = color;

        Destroy(gameObject, duration);
    }

    void Update()
    {
        if (sr == null) return;

        Color color = sr.color;
        color.a -= Time.deltaTime / duration;
        sr.color = color;
    }
}
</file>

<file path="Assets/Scripts/EnemySpawner.cs">
// EnemySpawner.cs
using UnityEngine;

public class EnemySpawner : MonoBehaviour
{
    public GameObject enemyPrefab;
    public float spawnRate = 2f; // Inimigos por segundo
    public float spawnRadius = 15f; // Distância do jogador onde os inimigos aparecem

    private Transform player;
    private Transform bonfire;

    void Start()
    {
        player = FindObjectOfType<PlayerController>().transform; // Encontra o jogador
        bonfire = GameObject.FindGameObjectWithTag("Bonfire").transform; // Encontra a fogueira
        InvokeRepeating("SpawnEnemy", 1f, 1f / spawnRate);
    }

    void SpawnEnemy()
    {
        // Pega uma direção aleatória e a multiplica pelo raio
        Vector2 spawnPos = bonfire.position;
        spawnPos += Random.insideUnitCircle.normalized * spawnRadius;

        Instantiate(enemyPrefab, spawnPos, Quaternion.identity);
    }
}
</file>

<file path="Assets/Scripts/JiggleEffect.cs">
using UnityEngine;
using DG.Tweening;

public class JiggleEffect : MonoBehaviour
{
    [Header("Configuração do Jiggle")]
    public float scaleAmount = 0.05f;       // Quanto a escala oscila
    public float positionAmount = 0.05f;    // Quanto a posição oscila
    public float duration = 0.3f;           // Duração de cada fase

    private Vector3 originalScale;
    private Vector3 originalPos;

    void Start()
    {
        originalScale = transform.localScale;
        originalPos = transform.localPosition;

        StartJiggle();
    }

    void StartJiggle()
    {
        Sequence seq = DOTween.Sequence().SetLoops(-1, LoopType.Yoyo);

        seq.Append(transform.DOScale(originalScale + new Vector3(scaleAmount, -scaleAmount, 0), duration).SetEase(Ease.InOutSine));
        seq.Join(transform.DOLocalMove(originalPos + new Vector3(positionAmount, positionAmount, 0), duration).SetEase(Ease.InOutSine));

        seq.Append(transform.DOScale(originalScale + new Vector3(-scaleAmount, scaleAmount, 0), duration).SetEase(Ease.InOutSine));
        seq.Join(transform.DOLocalMove(originalPos + new Vector3(-positionAmount, -positionAmount, 0), duration).SetEase(Ease.InOutSine));
    }
}
</file>

<file path="Assets/Scripts/LightFlicker.cs">
using UnityEngine;
using UnityEngine.Rendering.Universal;

[RequireComponent(typeof(Light2D))]
public class LightFlicker : MonoBehaviour
{
    [Header("Intensidade")]
    public float baseIntensity = 1f;
    public float intensityVariation = 0.2f;

    [Header("Raio da luz")]
    public float baseOuterRadius = 5f;
    public float radiusVariation = 0.2f;

    [Header("Velocidade da oscilação")]
    public float flickerSpeed = 0.1f;

    private Light2D light2D;
    private float flickerTimer;

    void Start()
    {
        light2D = GetComponent<Light2D>();
    }

    void Update()
    {
        flickerTimer += Time.deltaTime;
        if (flickerTimer >= flickerSpeed)
        {
            flickerTimer = 0f;

            float newIntensity = baseIntensity + Random.Range(-intensityVariation, intensityVariation);
            float newOuterRadius = baseOuterRadius + Random.Range(-radiusVariation, radiusVariation);

            light2D.intensity = Mathf.Clamp(newIntensity, 0, 10);
            light2D.pointLightOuterRadius = Mathf.Clamp(newOuterRadius, 0, 20);
        }
    }
}
</file>

<file path="Assets/Scripts/SwordSlashEffect.cs">
using UnityEngine;
using DG.Tweening;

[RequireComponent(typeof(SpriteRenderer))]
public class SwordSlashEffect : MonoBehaviour
{
    [Header("Configurações da Animação")]
    [Tooltip("Duração total da animação do corte, em segundos.")]
    public float animationDuration = 0.3f;

    [Tooltip("Escala final que o sprite irá atingir.")]
    public float targetScale = 1.5f;

    [Tooltip("Rotação final do sprite em graus. Use valores como 90, -90, etc., para mudar a direção do corte.")]
    public float targetRotation = 45f;

    private SpriteRenderer spriteRenderer;

    void Awake()
    {
        // Garante que temos a referência do SpriteRenderer
        spriteRenderer = GetComponent<SpriteRenderer>();
        if (spriteRenderer == null)
        {
            Debug.LogError("SwordSlashEffect precisa de um componente SpriteRenderer neste GameObject!");
            Destroy(gameObject); // Destrói se não houver sprite para animar
        }
    }

    void Start()
    {
        // Garante que o alfa inicial do sprite seja 1 (totalmente visível)
        Color startColor = spriteRenderer.color;
        startColor.a = 1f;
        spriteRenderer.color = startColor;

        // Inicia o sprite com escala zero para que ele "apareça" do nada
        transform.localScale = Vector3.zero;

        // Cria e executa a sequência de animação com DOTween
        AnimateSlash();
    }

    private void AnimateSlash()
    {
        // Cria uma sequência para rodar várias animações ao mesmo tempo
        Sequence slashSequence = DOTween.Sequence();

        // 1. Animação de Escala: cresce do zero até a escala alvo.
        slashSequence.Join(transform.DOScale(targetScale, animationDuration)
            .SetEase(Ease.OutQuad)); // Ease.OutQuad dá uma sensação de "explosão" inicial

        // 2. Animação de Fade: desaparece ao longo da duração.
        slashSequence.Join(spriteRenderer.DOFade(0f, animationDuration)
            .SetEase(Ease.InQuad)); // Ease.InQuad faz o fade acelerar no final

        // // 3. Animação de Rotação: gira para dar um efeito de arco.
        // slashSequence.Join(transform.DORotate(new Vector3(0, 0, targetRotation), animationDuration, RotateMode.FastBeyond360)
        //     .SetEase(Ease.OutSine));

        // Define uma ação para ser executada QUANDO a sequência terminar
        slashSequence.OnComplete(() =>
        {
            // Destrói o GameObject ao final de toda a animação
            Destroy(gameObject);
        });
    }
}
</file>

<file path="Assets/Scripts/ThrownWood.cs">
// ThrownWood.cs
using UnityEngine;
using DG.Tweening;

[RequireComponent(typeof(Rigidbody2D))]
public class ThrownWood : MonoBehaviour
{
    [Header("Configuração da Animação")]
    public float arcHeight = 2f;
    public float spinSpeed = 720f;

    // Flag para controlar se a lenha pode ser coletada
    public bool isCollectible = false;

    private void Start()
    {
        Rigidbody2D rb = GetComponent<Rigidbody2D>();
        rb.isKinematic = true;
        
        Collider2D col = GetComponent<Collider2D>();
        if (col != null) col.isTrigger = true;

        // Torna a lenha coletável após um curto período para evitar
        // que o jogador a pegue de volta instantaneamente.
        // DOVirtual.DelayedCall é uma forma limpa do DOTween de fazer um timer.
        DOVirtual.DelayedCall(0.2f, () => {
            isCollectible = true;
        });
    }

    public void Launch(Vector3 targetPosition, float duration)
    {
        // ... seu código de Launch continua exatamente o mesmo ...
        Sequence launchSequence = DOTween.Sequence();
        Vector3 startPoint = transform.position;
        Vector3 midPoint = Vector3.Lerp(startPoint, targetPosition, 0.5f) + (Vector3.up * arcHeight);
        Vector3[] path = { midPoint, targetPosition };
        launchSequence.Append(transform.DOPath(path, duration, PathType.CatmullRom).SetEase(Ease.OutQuad));
        launchSequence.Join(transform.DORotate(new Vector3(0, 0, spinSpeed * duration), duration, RotateMode.FastBeyond360).SetEase(Ease.Linear));
    }
}
</file>

<file path="Assets/Scripts/UpgradeData.cs">
// Assets/Scripts/UpgradeData.cs
using UnityEngine;

// Enum para identificar facilmente o tipo de upgrade
public enum UpgradeType
{
    WoodDropChance,
    PlayerAttackSpeed,
    BonfireBurnRate,
    BonfireMaxHealth,
    HealBonfire,
    PlayerMoveSpeed
}

[CreateAssetMenu(fileName = "New Upgrade", menuName = "Game/Upgrade Data")]
public class UpgradeData : ScriptableObject
{
    [Header("Info")]
    public string upgradeName;
    [TextArea]
    public string description;
    public Sprite icon;

    [Header("Configuração")]
    public UpgradeType type;
    public float value; // O valor do upgrade (ex: 1.15 para 15% de chance)
}
</file>

<file path="Assets/Scripts/UpgradeUIManager.cs">
// Assets/Scripts/UpgradeUIManager.cs
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using TMPro;

public class UpgradeUIManager : MonoBehaviour
{
    public GameObject upgradePanel;
    public List<Button> upgradeButtons;
    public List<TextMeshProUGUI> upgradeNameTexts;
    public List<TextMeshProUGUI> upgradeDescriptionTexts;
    public List<Image> upgradeIcons;

    public void ShowUpgradeOptions(List<UpgradeData> upgrades)
    {
        upgradePanel.SetActive(true);
        GetComponent<UIJuice>().PlayAnimation();


        for (int i = 0; i < upgradeButtons.Count; i++)
        {
            if (i < upgrades.Count)
            {
                // Ativa e configura o botão
                upgradeButtons[i].gameObject.SetActive(true);
                upgradeNameTexts[i].text = upgrades[i].upgradeName;
                upgradeDescriptionTexts[i].text = upgrades[i].description;
                upgradeIcons[i].sprite = upgrades[i].icon;

                // Limpa listeners antigos e adiciona o novo
                upgradeButtons[i].onClick.RemoveAllListeners();
                var selectedUpgrade = upgrades[i]; // Variável local para evitar problemas de closure
                upgradeButtons[i].onClick.AddListener(() => GameManager.Instance.ApplyUpgrade(selectedUpgrade));
            }
            else
            {
                // Desativa botões não utilizados
                upgradeButtons[i].gameObject.SetActive(false);
            }
        }
    }

    public void HidePanel()
    {
        GetComponent<UIJuice>().PlayReverseAnimation();
    }
}
</file>

<file path="Assets/Scripts/Enemy.cs">
// Assets/Scripts/Enemy.cs
using UnityEngine;
using DG.Tweening;

public class Enemy : MonoBehaviour
{
    [Header("Atributos")]
    public float speed = 3f;
    public int maxHealth = 2;
    private int currentHealth;

    [Header("Alvo")]
    private Transform target;

    // --- NOVO ---
    [Header("Drops")]
    [Tooltip("O prefab da lenha que o inimigo pode dropar ao morrer.")]
    public GameObject woodDropPrefab;
    [Tooltip("A chance de dropar a lenha, de 0.0 a 1.0 (ex: 0.5 para 50%).")]
    [Range(0f, 1f)]
    public float woodDropChance = 0.5f;
    // --- FIM DO NOVO ---

    private SpriteRenderer sr;

    void Start()
    {
        currentHealth = maxHealth;
        sr = GetComponent<SpriteRenderer>();

        GameObject bonfireObject = GameObject.FindGameObjectWithTag("Bonfire");
        if (bonfireObject != null)
        {
            target = bonfireObject.transform;
        }
        else
        {
            Debug.LogError("Inimigo não encontrou a fogueira! Verifique se o objeto Bonfire tem a tag 'Bonfire'.");
        }
    }

    void Update()
    {
        if (target != null)
        {
            transform.position = Vector2.MoveTowards(transform.position, target.position, speed * Time.deltaTime);
        }
    }

    public void TakeDamage(int damage)
    {
        currentHealth -= damage;

        if (sr != null)
        {
            sr.DOColor(Color.white, 0.1f).SetLoops(2, LoopType.Yoyo);
        }

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    // --- MÉTODO ATUALIZADO ---// Em Enemy.cs, método Die()

private void Die()
{
        GameManager.Instance.SpawnBlueExplosion(transform.position);

    if (woodDropPrefab != null)
        {
            // Lógica de drop atualizada para incluir o bônus do GameManager
            float totalDropChance = woodDropChance + GameManager.Instance.bonusWoodDropChance;
            if (Random.value < totalDropChance)
            {
                Instantiate(woodDropPrefab, transform.position, Quaternion.identity);
            }
        }
    Destroy(gameObject);
}
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Bonfire"))
        {
            collision.GetComponent<Bonfire>().ReceberDano(1); // Exemplo de dano
            Die(); // O inimigo morre ao tocar a fogueira também
        }
    }
}
</file>

<file path="Assets/Scripts/Bonfire.cs">
// Dentro de public class Bonfire : MonoBehaviour
using System;
using UnityEngine;
public class Bonfire : MonoBehaviour
{
    // Substitua "energia" por um sistema de vida atual/máxima
    public float maxHealth = 100f;
    public float currentHealth;
    public float taxaDePerdaDeEnergia = 0.5f; // Agora é um stat público
    public LightFlicker luzDaFogueira; // Arraste o objeto da luz da fogueira aqui no Inspector

    void Start()
    {
        currentHealth = maxHealth;
        // Adicione uma verificação para a luz, se ela for essencial
        if (luzDaFogueira == null)
        {
            Debug.LogError("A referência para LightFlicker não foi definida no Bonfire!");
        }
    }

    void Update()
    {
        currentHealth -= taxaDePerdaDeEnergia * Time.deltaTime;

        if (luzDaFogueira != null)
        {
            // Mapeia a vida (0 a maxHealth) para a intensidade da luz
            luzDaFogueira.baseIntensity = Mathf.Lerp(0.3f, 1.5f, currentHealth / maxHealth);
            luzDaFogueira.baseOuterRadius = Mathf.Lerp(2f, 7f, currentHealth / maxHealth);
        }


        // Condição de derrota (Game Over)
        if (currentHealth <= 0)
        {
            Debug.Log("A FOGUEIRA APAGOU! GAME OVER.");
            // Aqui você pode adicionar a lógica de fim de jogo, como:
            // Time.timeScale = 0; // Pausa o jogo
            // Mostrar uma tela de "Game Over"
        }
    }

    // O OnTriggerEnter2D para lenha agora acontece no Player, então este pode ser simplificado ou removido
    // Se outros objetos além da lenha podem interagir, mantenha-o. Senão, pode apagar.
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Lenha"))
        {
            // Aqui você pode adicionar lógica para coletar a lenha, como:
            GameManager.Instance.AddXp(1);
            Destroy(collision.gameObject); // Remove a lenha do jogo
            currentHealth += 10; // Por exemplo, adiciona 10 de vida à fogueira
            currentHealth = Mathf.Min(currentHealth, maxHealth); // Garante que não ultrapasse o máximo
            Debug.Log("Lenha coletada! Vida da fogueira aumentada.");
            GameManager.Instance.SpawnOrangeExplosion(transform.position); // Efeito visual de coleta
        }
          }

    public void ReceberDano(int dano)
    {
        currentHealth -= dano;
    }

    // --- NOVOS MÉTODOS PARA UPGRADES ---
    public void IncreaseMaxHealth(float multiplier)
    {
        float oldMaxHealth = maxHealth;
        maxHealth *= multiplier;
        // Cura a fogueira pela quantidade que a vida máxima aumentou
        currentHealth += maxHealth - oldMaxHealth;
        currentHealth = Mathf.Clamp(currentHealth, 0, maxHealth); // Garante que não ultrapasse o novo máximo
    }

    public void HealToFull()
    {
        currentHealth = maxHealth;
    }
}
</file>

<file path="Assets/Scripts/GameManager.cs">
// Assets/Scripts/GameManager.cs
using System.Collections.Generic;
using System.Linq;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.VFX;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    [Header("Referências")]
    public PlayerController player;
    public Bonfire bonfire;
    public UpgradeUIManager upgradeUI; // Vamos criar este script a seguir

    [Header("Controle de Nível")]
    public int playerLevel = 1;
    private int currentXp = 0;
    // Custo de XP para cada nível (Nível 1 custa 1, Nível 2 custa 3, etc.)
    public int[] xpPerLevel = { 1, 3, 5, 8, 12, 17, 23, 30, 38, 47 }; // Curva até o Nível 10

    [Header("Upgrades")]
    [Tooltip("Lista com todos os upgrades possíveis no jogo.")]
    public List<UpgradeData> allUpgrades;
    private List<UpgradeData> availableUpgrades;

    public ParticleSystem confettiEffect, orangeExplosionEffect, blueExplosionEffect;
    // Stats Globais Modificáveis
    public float bonusWoodDropChance = 0f;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        // Reseta a lista de upgrades disponíveis no início
        availableUpgrades = new List<UpgradeData>(allUpgrades);
    }


    public void AddXp(int amount)
    {
        if (playerLevel > xpPerLevel.Length) return; // Nível máximo atingido

        currentXp += amount;
        Debug.Log($"Ganhou {amount} XP. Total: {currentXp}/{xpPerLevel[playerLevel - 1]}");

        // Verifica se alcançou o XP necessário para o próximo nível
        if (currentXp >= xpPerLevel[playerLevel - 1])
        {
            LevelUp();
        }
    }

    private void LevelUp()
    {
        // Subtrai o custo do nível atual
        currentXp -= xpPerLevel[playerLevel - 1];
        playerLevel++;
        ShowConfetti();
        Debug.Log($"LEVEL UP! Novo nível: {playerLevel}");

        Time.timeScale = 0f; // Pausa o jogo

        // Seleciona 3 upgrades aleatórios
        List<UpgradeData> selectedUpgrades = new List<UpgradeData>();
        var randomUpgrades = availableUpgrades.OrderBy(x => Random.value).ToList();

        int count = Mathf.Min(3, randomUpgrades.Count);
        for (int i = 0; i < count; i++)
        {
            selectedUpgrades.Add(randomUpgrades[i]);
        }

        // Mostra a tela de upgrade
        upgradeUI.ShowUpgradeOptions(selectedUpgrades);
    }

    public void ApplyUpgrade(UpgradeData upgrade)
    {
        Debug.Log($"Upgrade selecionado: {upgrade.upgradeName}");
        switch (upgrade.type)
        {
            case UpgradeType.WoodDropChance:
                bonusWoodDropChance += upgrade.value; // Acumula a chance bônus
                break;
            case UpgradeType.PlayerAttackSpeed:
                player.attackCooldown *= (1f / upgrade.value); // Ex: 1.25x speed -> cooldown * (1/1.25)
                break;
            case UpgradeType.BonfireBurnRate:
                bonfire.taxaDePerdaDeEnergia *= upgrade.value; // Ex: 0.9x burn rate
                break;
            case UpgradeType.BonfireMaxHealth:
                bonfire.IncreaseMaxHealth(upgrade.value);
                break;
            case UpgradeType.HealBonfire:
                bonfire.HealToFull();
                break;
            case UpgradeType.PlayerMoveSpeed:
                player.moveSpeed *= upgrade.value;
                break;
        }

        // Remove o upgrade da lista para não ser oferecido de novo (opcional, mas bom)
        // availableUpgrades.Remove(upgrade);

        // Despausa o jogo
        Time.timeScale = 1f;
        upgradeUI.HidePanel();

    }

    public void ShowConfetti()
    {
        if (confettiEffect != null)
        {
            confettiEffect.Play();
        }
    }

    public void SpawnOrangeExplosion(Vector3 position)
    {
        if (orangeExplosionEffect != null)
        {
            var effect = Instantiate(orangeExplosionEffect, position, Quaternion.identity);
            // move a little in z
            effect.transform.position += new Vector3(0, 0, -1f);
        }
    }
    
    public void SpawnOrangeExplosionOnBonfire()
    {
        if (bonfire != null)
        {
            SpawnOrangeExplosion(bonfire.transform.position);
        }
    }

    public void SpawnBlueExplosion(Vector3 position)
    {
        if (blueExplosionEffect != null)
        {
            var effect = Instantiate(blueExplosionEffect, position, Quaternion.identity);
            // move a little in z
            effect.transform.position += new Vector3(0, 0, -1f);

        }
    }

}
</file>

<file path="Assets/Scripts/PlayerController.cs">
using System.Linq;
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class PlayerController : MonoBehaviour
{
    [Header("Movimentação")]
    public float moveSpeed = 8f;
    public float acceleration = 10f;

    [Header("Dash")]
    public float dashForce = 12f;
    public float dashDuration = 0.2f;
    public float dashCooldown = 2f;
    public KeyCode dashKey = KeyCode.Space;

    [Header("Lançar Lenha")]
    public GameObject woodPrefab;
    public float throwForce = 10f;
    public Transform woodSpawnPoint;

    [Header("Inventário")]
    public int lenhaNoInventario = 0;

    private Rigidbody2D rb;
    private Vector2 input;
    private bool isDashing = false;
    private float lastDashTime = -Mathf.Infinity;

    [Header("Ataque Melee Automático")]
    public float attackRadius = 2.5f;   // O alcance do ataque
    public float attackCooldown = 1f;   // Ataca a cada 1 segundo
    public int attackDamage = 1;        // Dano do ataque
    public LayerMask enemyLayer;        // Defina no Inspector qual camada é a dos inimigos
    public GameObject slashEffectPrefab;        // Efeito visual opcional para o ataque
    private float lastAttackTime = -Mathf.Infinity; // Timer para o ataque

    [Header("Lançar Lenha")]
    public float throwDuration = 0.7f; // Duração do voo da lenha
    private LineRenderer aimLine;
    private Transform bonfireTransform;
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();

        // Pega a referência do LineRenderer e o desativa
        aimLine = GetComponent<LineRenderer>();
        aimLine.enabled = false;

        // Encontra a fogueira na cena para saber o alvo do arremesso
        GameObject bonfireObj = GameObject.FindGameObjectWithTag("Bonfire");
        if (bonfireObj != null)
        {
            bonfireTransform = bonfireObj.transform;
        }
    }

    void Update()
    {
        HandleInput();
        HandleDashInput();
        // HandleAimingAndThrowing(); // Substitui o antigo HandleThrowInput
        HandleMeleeAttack();
    }

    void FixedUpdate()
    {
        if (!isDashing)
        {
            Vector2 targetVelocity = input * moveSpeed;
            rb.velocity = Vector2.Lerp(rb.velocity, targetVelocity, acceleration * Time.fixedDeltaTime);
        }
    }

    // NOVO: Lógica do ataque automático
    void HandleMeleeAttack()
    {
        // A lógica para verificar o cooldown permanece a mesma
        if (Time.time >= lastAttackTime + attackCooldown)
        {
            Collider2D[] enemiesInRange = Physics2D.OverlapCircleAll(transform.position, attackRadius, enemyLayer);

            if (enemiesInRange.Length > 0)
            {
                Transform closestEnemy = enemiesInRange
                    .OrderBy(enemy => Vector2.Distance(transform.position, enemy.transform.position))
                    .FirstOrDefault()?.transform;

                if (closestEnemy != null)
                {
                    lastAttackTime = Time.time;
                    Enemy enemyScript = closestEnemy.GetComponent<Enemy>();

                    if (enemyScript != null)
                    {
                        enemyScript.TakeDamage(attackDamage);

                        // --- INÍCIO DA LÓGICA DE ROTAÇÃO ---

                        if (slashEffectPrefab != null)
                        {
                            // 1. Calcula o vetor de direção do jogador para o inimigo.
                            //    Isso nos dá a "seta" que aponta para o alvo.
                            Vector2 directionToEnemy = (closestEnemy.position - transform.position).normalized;

                            // 2. Converte essa direção em um ângulo em graus.
                            //    Mathf.Atan2 é perfeito para isso, e Rad2Deg converte de radianos para graus.
                            float angle = Mathf.Atan2(directionToEnemy.y, directionToEnemy.x) * Mathf.Rad2Deg;

                            // 3. Cria a rotação final (Quaternion) que será usada na instanciação.
                            //    A rotação acontece no eixo Z em um jogo 2D.
                            Quaternion targetRotation = Quaternion.Euler(0f, 0f, angle);

                            // 4. Instancia o prefab na posição do inimigo e com a rotação que acabamos de calcular.
                            //    Substituímos o Quaternion.identity pela nossa targetRotation.
                            Instantiate(slashEffectPrefab, closestEnemy.position, targetRotation);


                        }

                        // --- FIM DA LÓGICA DE ROTAÇÃO ---
                    }
                }
            }
        }
    }

    // ... Seus outros métodos (HandleInput, Dash, etc.) ...
    void HandleInput()
    {
        input = new Vector2(Input.GetAxisRaw("Horizontal"), Input.GetAxisRaw("Vertical")).normalized;
    }

    System.Collections.IEnumerator Dash()
    {
        isDashing = true;
        lastDashTime = Time.time;
        Vector2 dashDir = input != Vector2.zero ? input : (transform.up);
        rb.velocity = dashDir.normalized * dashForce;
        yield return new WaitForSeconds(dashDuration);
        isDashing = false;
    }


    void HandleDashInput()
    {
        if (Input.GetKeyDown(dashKey) && Time.time >= lastDashTime + dashCooldown && !isDashing)
        {
            StartCoroutine(Dash());
        }
    }

    // Dentro de PlayerController.cs

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag("Lenha"))
        {
            // Pega o script da lenha que colidiu
            ThrownWood woodScript = collision.GetComponent<ThrownWood>();

            // Se a lenha não existir ou não for coletável, ignora.
            // O "woodScript == null" é para lenhas que podem estar no chão sem esse script.
            if (woodScript != null && !woodScript.isCollectible)
            {
                return;
            }

            // Se passar, a lenha é coletável.
            lenhaNoInventario++;
            Destroy(collision.gameObject);
            ThrowWood(); // Lança a lenha automaticamente ao coletar
        }
    }
    // NOVO: Visualizar o raio de ataque no Editor da Unity
    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;
        Gizmos.DrawWireSphere(transform.position, attackRadius);
    }

    void HandleAimingAndThrowing()
    {
        // Se não tiver lenha, não faz nada
        if (lenhaNoInventario <= 0 || bonfireTransform == null)
        {
            aimLine.enabled = false;
            return;
        }

        // Pega a posição do mouse no mundo do jogo
        Vector3 mouseWorldPos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
        mouseWorldPos.z = 0f;

        // Ponto de onde a lenha/mira sai
        Vector3 spawnPos = woodSpawnPoint != null ? woodSpawnPoint.position : transform.position;

        // Enquanto o botão do mouse estiver pressionado, mostra a mira
        if (Input.GetMouseButton(0))
        {
            aimLine.enabled = true;
            // A mira aponta do jogador na direção do mouse
            aimLine.SetPosition(0, spawnPos);
            aimLine.SetPosition(1, mouseWorldPos);
        }

        // Ao soltar o botão, arremessa a lenha
        if (Input.GetMouseButtonUp(0))
        {
            aimLine.enabled = false; // Esconde a mira

            lenhaNoInventario--;
            // AudioManager.Instance.PlaySoundEffect(SEU_INDICE_DE_ARREMESSO_AQUI);

            GameObject wood = Instantiate(woodPrefab, spawnPos, Quaternion.identity);
            ThrownWood thrownWoodScript = wood.GetComponent<ThrownWood>();

            if (thrownWoodScript != null)
            {
                // Inicia a animação de arremesso em direção à fogueira
                thrownWoodScript.Launch(bonfireTransform.position, throwDuration);
            }
        }

        // Se o jogador soltar o clique sem querer, esconde a linha
        if (!Input.GetMouseButton(0) && aimLine.enabled)
        {
            aimLine.enabled = false;
        }
    }
    public void ThrowWood()
    {
        
            lenhaNoInventario--;
            // AudioManager.Instance.PlaySoundEffect(SEU_INDICE_DE_ARREMESSO_AQUI);

            GameObject wood = Instantiate(woodPrefab, transform.position, Quaternion.identity);
            ThrownWood thrownWoodScript = wood.GetComponent<ThrownWood>();

            if (thrownWoodScript != null)
            {
                // Inicia a animação de arremesso em direção à fogueira
                thrownWoodScript.Launch(bonfireTransform.position, throwDuration);
            }
    }
}
</file>

</files>
